<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/*!
 * Ext Server
 * Copyright (c)2012 Xenophy.CO.,LTD All rights Reserved.
 * MIT Licensed
 */

// {{{ Ext.Base

<span id='Ext-Base'>/**
</span> * @class Ext.Base
 *
 * {Ext_Base:doc-contents}
 */
(function(flexSetter) {

    var noArgs = [],
        Base = function(){};

    Ext.apply(Base, {

        // {{{ $className

        $className: 'Ext.Base',

        // }}}
        // {{{ $isClass

        $isClass: true,

        // }}}
        // {{{ create

<span id='Ext-Base-static-method-create'>        /**
</span>         * {Ext_Base:method-create:desc}
         *
         * @return {Object} {Ext_Base:method-create:return}
         * @static
         * @inheritable
         */
        create: function() {
            return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
        },

        // }}}
        // {{{ extend

<span id='Ext-Base-method-extend'>        /**
</span>         * @private
         * @param config
         */
        extend: function(parent) {

            var parentPrototype = parent.prototype,
                basePrototype, prototype, i, ln, name, statics;

            prototype = this.prototype = Ext.Object.chain(parentPrototype);
            prototype.self = this;

            this.superclass = prototype.superclass = parentPrototype;

            if(!parent.$isClass) {

                basePrototype = Ext.Base.prototype;

                for(i in basePrototype) {
                    if(i in prototype) {
                        prototype[i] = basePrototype[i];
                    }
                }
            }

            //&lt;feature classSystem.inheritableStatics&gt;
            // Statics inheritance
            statics = parentPrototype.$inheritableStatics;

            if (statics) {
                for (i = 0,ln = statics.length; i &lt; ln; i++) {
                    name = statics[i];

                    if (!this.hasOwnProperty(name)) {
                        this[name] = parent[name];
                    }
                }
            }
            //&lt;/feature&gt;

            if (parent.$onExtended) {
                this.$onExtended = parent.$onExtended.slice();
            }

            //&lt;feature classSystem.config&gt;
            prototype.config = new prototype.configClass();
            prototype.initConfigList = prototype.initConfigList.slice();
            prototype.initConfigMap = Ext.clone(prototype.initConfigMap);
            prototype.configMap = Ext.Object.chain(prototype.configMap);
            //&lt;/feature&gt;
        },

        // }}}
        // {{{ $onExtended

<span id='Ext-Base-method-S-onExtended'>        /**
</span>         * @private
         * @param config
         */
        '$onExtended': [],

        // }}}
        // {{{ triggerExtended

<span id='Ext-Base-method-triggerExtended'>        /**
</span>         * @private
         * @param config
         */
        triggerExtended: function() {
            var callbacks = this.$onExtended,
                ln = callbacks.length,
                i, callback;

            if (ln &gt; 0) {
                for (i = 0; i &lt; ln; i++) {
                    callback = callbacks[i];
                    callback.fn.apply(callback.scope || this, arguments);
                }
            }
        },

        // }}}
        // {{{ onExtended

<span id='Ext-Base-method-onExtended'>        /**
</span>         * @private
         * @param config
         */
        onExtended: function(fn, scope) {
            this.$onExtended.push({
                fn: fn,
                scope: scope
            });

            return this;
        },

        // }}}
        // {{{ addConfig

<span id='Ext-Base-method-addConfig'>        /**
</span>         * @private
         * @param config
         */
        addConfig: function(config, fullMerge) {
            var prototype = this.prototype,
                configNameCache = Ext.Class.configNameCache,
                hasConfig = prototype.configMap,
                initConfigList = prototype.initConfigList,
                initConfigMap = prototype.initConfigMap,
                defaultConfig = prototype.config,
                initializedName, name, value;

            for (name in config) {
                if (config.hasOwnProperty(name)) {
                    if (!hasConfig[name]) {
                        hasConfig[name] = true;
                    }

                    value = config[name];

                    initializedName = configNameCache[name].initialized;

                    if (!initConfigMap[name] &amp;&amp; value !== null &amp;&amp; !prototype[initializedName]) {
                        initConfigMap[name] = true;
                        initConfigList.push(name);
                    }
                }
            }

            if (fullMerge) {
                Ext.merge(defaultConfig, config);
            }
            else {
                Ext.mergeIf(defaultConfig, config);
            }

            prototype.configClass = Ext.Object.classify(defaultConfig);
        },

        // }}}
        // {{{ addStatics

<span id='Ext-Base-static-method-addStatics'>        /**
</span>         * Add / override static properties of this class.
         *
         *     Ext.define('My.cool.Class', {
         *         ...
         *     });
         *
         *     My.cool.Class.addStatics({
         *         someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
         *         method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
         *         method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
         *     });
         *
         * @param {Object} members
         * @return {Ext.Base} this
         * @static
         * @inheritable
         */
        addStatics: function(members) {
            var member, name;

            for (name in members) {
                if (members.hasOwnProperty(name)) {
                    member = members[name];
                    //&lt;debug&gt;
                    if (typeof member == 'function') {
                        member.displayName = Ext.getClassName(this) + '.' + name;
                    }
                    //&lt;/debug&gt;
                    this[name] = member;
                }
            }

            return this;
        },

        // }}}
        // {{{ addInheritableStatics

<span id='Ext-Base-method-addInheritableStatics'>        /**
</span>         * @private
         * @param {Object} members
         */
        addInheritableStatics: function(members) {
            var inheritableStatics,
                hasInheritableStatics,
                prototype = this.prototype,
                name, member;

            inheritableStatics = prototype.$inheritableStatics;
            hasInheritableStatics = prototype.$hasInheritableStatics;

            if (!inheritableStatics) {
                inheritableStatics = prototype.$inheritableStatics = [];
                hasInheritableStatics = prototype.$hasInheritableStatics = {};
            }

            for (name in members) {
                if (members.hasOwnProperty(name)) {
                    member = members[name];
                    //&lt;debug&gt;
                    if (typeof member == 'function') {
                        member.displayName = Ext.getClassName(this) + '.' + name;
                    }
                    //&lt;/debug&gt;
                    this[name] = member;

                    if (!hasInheritableStatics[name]) {
                        hasInheritableStatics[name] = true;
                        inheritableStatics.push(name);
                    }
                }
            }

            return this;
        },

        // }}}
        // {{{ addMembers

<span id='Ext-Base-static-method-addMembers'>        /**
</span>         * Add methods / properties to the prototype of this class.
         *
         *     Ext.define('My.awesome.Cat', {
         *         constructor: function() {
         *             ...
         *         }
         *     });
         *
         *      My.awesome.Cat.implement({
         *          meow: function() {
         *             alert('Meowww...');
         *          }
         *      });
         *
         *      var kitty = new My.awesome.Cat;
         *      kitty.meow();
         *
         * @param {Object} members
         * @static
         * @inheritable
         */
        addMembers: function(members) {
            var prototype = this.prototype,
                enumerables = Ext.enumerables,
                names = [],
                i, ln, name, member;

            for (name in members) {
                names.push(name);
            }

            if (enumerables) {
                names.push.apply(names, enumerables);
            }

            for (i = 0,ln = names.length; i &lt; ln; i++) {
                name = names[i];

                if (members.hasOwnProperty(name)) {
                    member = members[name];

                    if (typeof member == 'function' &amp;&amp; !member.$isClass &amp;&amp; member !== Ext.emptyFn) {
                        member.$owner = this;
                        member.$name = name;
                        //&lt;debug&gt;
                        member.displayName = (this.$className || '') + '#' + name;
                        //&lt;/debug&gt;
                    }

                    prototype[name] = member;
                }
            }

            return this;
        },

        // }}}
        // {{{ addMember

<span id='Ext-Base-method-addMember'>        /**
</span>         * @private
         * @param name
         * @param member
         */
        addMember: function(name, member) {
            if (typeof member == 'function' &amp;&amp; !member.$isClass &amp;&amp; member !== Ext.emptyFn) {
                member.$owner = this;
                member.$name = name;
                //&lt;debug&gt;
                member.displayName = (this.$className || '') + '#' + name;
                //&lt;/debug&gt;
            }

            this.prototype[name] = member;

            return this;
        },

        // }}}
        // {{{ implement

<span id='Ext-Base-method-implement'>        /**
</span>         * @private
         */
        implement: function() {
            this.addMembers.apply(this, arguments);
        },

        // }}}
        // {{{ borrow

<span id='Ext-Base-static-method-borrow'>        /**
</span>         * Borrow another class' members to the prototype of this class.
         *
         *     Ext.define('Bank', {
         *         money: '$$$',
         *         printMoney: function() {
         *             alert('$$$$$$$');
         *         }
         *     });
         *
         *     Ext.define('Thief', {
         *         ...
         *     });
         *
         *     Thief.borrow(Bank, ['money', 'printMoney']);
         *
         *     var steve = new Thief();
         *
         *     alert(steve.money); // alerts '$$$'
         *     steve.printMoney(); // alerts '$$$$$$$'
         *
         * @param {Ext.Base} fromClass The class to borrow members from
         * @param {Array/String} members The names of the members to borrow
         * @return {Ext.Base} this
         * @static
         * @inheritable
         * @private
         */
        borrow: function(fromClass, members) {
            var prototype = this.prototype,
                fromPrototype = fromClass.prototype,
                //&lt;debug&gt;
                className = Ext.getClassName(this),
                //&lt;/debug&gt;
                i, ln, name, fn, toBorrow;

            members = Ext.Array.from(members);

            for (i = 0,ln = members.length; i &lt; ln; i++) {
                name = members[i];

                toBorrow = fromPrototype[name];

                if (typeof toBorrow == 'function') {
                    fn = Ext.Function.clone(toBorrow);

                    //&lt;debug&gt;
                    if (className) {
                        fn.displayName = className + '#' + name;
                    }
                    //&lt;/debug&gt;

                    fn.$owner = this;
                    fn.$name = name;

                    prototype[name] = fn;
                }
                else {
                    prototype[name] = toBorrow;
                }
            }

            return this;
        },

        // }}}
        // {{{ override

<span id='Ext-Base-static-method-override'>        /**
</span>         * Override members of this class. Overridden methods can be invoked via
         * {@link Ext.Base#callParent}.
         *
         *     Ext.define('My.Cat', {
         *         constructor: function() {
         *             alert(&quot;I'm a cat!&quot;);
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert(&quot;I'm going to be a cat!&quot;);
         *
         *             this.callParent(arguments);
         *
         *             alert(&quot;Meeeeoooowwww&quot;);
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts &quot;I'm going to be a cat!&quot;
         *                               // alerts &quot;I'm a cat!&quot;
         *                               // alerts &quot;Meeeeoooowwww&quot;
         *
         * As of 4.1, direct use of this method is deprecated. Use {@link Ext#define Ext.define}
         * instead:
         *
         *     Ext.define('My.CatOverride', {
         *         override: 'My.Cat',
         *         constructor: function() {
         *             alert(&quot;I'm going to be a cat!&quot;);
         *
         *             this.callParent(arguments);
         *
         *             alert(&quot;Meeeeoooowwww&quot;);
         *         }
         *     });
         *
         * The above accomplishes the same result but can be managed by the {@link Ext.Loader}
         * which can properly order the override and its target class and the build process
         * can determine whether the override is needed based on the required state of the
         * target class (My.Cat).
         *
         * @param {Object} members The properties to add to this class. This should be
         * specified as an object literal containing one or more properties.
         * @return {Ext.Base} this class
         * @static
         * @inheritable
         * @markdown
         * @deprecated 4.1.0 Use {@link Ext#define Ext.define} instead
         */
        override: function(members) {
            var me = this,
                enumerables = Ext.enumerables,
                target = me.prototype,
                cloneFunction = Ext.Function.clone,
                name, index, member, statics, names, previous;

            if (arguments.length === 2) {
                name = members;
                members = {};
                members[name] = arguments[1];
                enumerables = null;
            }

            do {
                names = []; // clean slate for prototype (1st pass) and static (2nd pass)
                statics = null; // not needed 1st pass, but needs to be cleared for 2nd pass

                for (name in members) { // hasOwnProperty is checked in the next loop...
                    if (name == 'statics') {
                        statics = members[name];
                    } else {
                        names.push(name);
                    }
                }

                if (enumerables) {
                    names.push.apply(names, enumerables);
                }

                for (index = names.length; index--; ) {
                    name = names[index];

                    if (members.hasOwnProperty(name)) {
                        member = members[name];

                        if (typeof member == 'function' &amp;&amp; !member.$className &amp;&amp; member !== Ext.emptyFn) {
                            if (typeof member.$owner != 'undefined') {
                                member = cloneFunction(member);
                            }

                            //&lt;debug&gt;
                            if (me.$className) {
                                member.displayName = me.$className + '#' + name;
                            }
                            //&lt;/debug&gt;

                            member.$owner = me;
                            member.$name = name;

                            previous = target[name];
                            if (previous) {
                                member.$previous = previous;
                            }
                        }

                        target[name] = member;
                    }
                }

                target = me; // 2nd pass is for statics
                members = statics; // statics will be null on 2nd pass
            } while (members);

            return this;
        },

        // }}}
        // {{{ callParent

        // Documented downwards
        callParent: function(args) {
            var method;

            // This code is intentionally inlined for the least number of debugger stepping
            return (method = this.callParent.caller) &amp;&amp; (method.$previous ||
                  ((method = method.$owner ? method : method.caller) &amp;&amp;
                        method.$owner.superclass.$class[method.$name])).apply(this, args || noArgs);
        },

        // }}}
        // {{{ mixin

        //&lt;feature classSystem.mixins&gt;
<span id='Ext-Base-method-mixin'>        /**
</span>         * Used internally by the mixins pre-processor
         * @private
         * @inheritable
         */
        mixin: function(name, mixinClass) {
            var mixin = mixinClass.prototype,
                prototype = this.prototype,
                key;

            if (typeof mixin.onClassMixedIn != 'undefined') {
                mixin.onClassMixedIn.call(mixinClass, this);
            }

            if (!prototype.hasOwnProperty('mixins')) {
                if ('mixins' in prototype) {
                    prototype.mixins = Ext.Object.chain(prototype.mixins);
                }
                else {
                    prototype.mixins = {};
                }
            }

            for (key in mixin) {
                if (key === 'mixins') {
                    Ext.merge(prototype.mixins, mixin[key]);
                }
                else if (typeof prototype[key] == 'undefined' &amp;&amp; key != 'mixinId' &amp;&amp; key != 'config') {
                    prototype[key] = mixin[key];
                }
            }

            //&lt;feature classSystem.config&gt;
            if ('config' in mixin) {
                this.addConfig(mixin.config, false);
            }
            //&lt;/feature&gt;

            prototype.mixins[name] = mixin;
        },
        //&lt;/feature&gt;

        // }}}
        // {{{ getName

<span id='Ext-Base-static-method-getName'>        /**
</span>         * Get the current class' name in string format.
         *
         *     Ext.define('My.cool.Class', {
         *         constructor: function() {
         *             alert(this.self.getName()); // alerts 'My.cool.Class'
         *         }
         *     });
         *
         *     My.cool.Class.getName(); // 'My.cool.Class'
         *
         * @return {String} className
         * @static
         * @inheritable
         */
        getName: function() {
            return Ext.getClassName(this);
        },

        // }}}
        // {{{ createAlias

<span id='Ext-Base-static-method-createAlias'>        /**
</span>         * {Ext_Base:method-createAlias:desc}
         *
         * @param {String/Object} alias {Ext_Base:method-createAlias:para_alias}
         * @param {String/Object} origin {Ext_Base:method-createAlias:para_origin}
         * @static
         * @inheritable
         * @method
         */
        createAlias: flexSetter(function(alias, origin) {
            this.override(alias, function() {
                return this[origin].apply(this, arguments);
            });
        })

        // }}}

    });

}(Ext.Function.flexSetter));

// }}}

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
